// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/schemachanger/targets/targets.proto

package targets

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"

import github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type State int32

const (
	State_UNKNOWN               State = 0
	State_ABSENT                State = 1
	State_DELETE_ONLY           State = 2
	State_DELETE_AND_WRITE_ONLY State = 3
	State_BACKFILLED            State = 4
	State_VALIDATED             State = 5
	State_PUBLIC                State = 6
)

var State_name = map[int32]string{
	0: "UNKNOWN",
	1: "ABSENT",
	2: "DELETE_ONLY",
	3: "DELETE_AND_WRITE_ONLY",
	4: "BACKFILLED",
	5: "VALIDATED",
	6: "PUBLIC",
}
var State_value = map[string]int32{
	"UNKNOWN":               0,
	"ABSENT":                1,
	"DELETE_ONLY":           2,
	"DELETE_AND_WRITE_ONLY": 3,
	"BACKFILLED":            4,
	"VALIDATED":             5,
	"PUBLIC":                6,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{0}
}

type TargetProto struct {
	AddColumn                     *AddColumn                     `protobuf:"bytes,1,opt,name=add_column,json=addColumn,proto3" json:"add_column,omitempty"`
	DropColumn                    *DropColumn                    `protobuf:"bytes,2,opt,name=drop_column,json=dropColumn,proto3" json:"drop_column,omitempty"`
	AddIndex                      *AddIndex                      `protobuf:"bytes,3,opt,name=add_index,json=addIndex,proto3" json:"add_index,omitempty"`
	DropIndex                     *DropIndex                     `protobuf:"bytes,4,opt,name=drop_index,json=dropIndex,proto3" json:"drop_index,omitempty"`
	AddSequenceDependency         *AddSequenceDependency         `protobuf:"bytes,5,opt,name=add_sequence_dependency,json=addSequenceDependency,proto3" json:"add_sequence_dependency,omitempty"`
	AddColumnFamilyDependency     *AddColumnFamily               `protobuf:"bytes,6,opt,name=add_column_family_dependency,json=addColumnFamilyDependency,proto3" json:"add_column_family_dependency,omitempty"`
	AddUniqueConstraint           *AddUniqueConstraint           `protobuf:"bytes,7,opt,name=add_unique_constraint,json=addUniqueConstraint,proto3" json:"add_unique_constraint,omitempty"`
	DropUniqueConstraint          *DropUniqueConstraint          `protobuf:"bytes,8,opt,name=drop_unique_constraint,json=dropUniqueConstraint,proto3" json:"drop_unique_constraint,omitempty"`
	AddCheckConstraint            *AddCheckConstraint            `protobuf:"bytes,9,opt,name=add_check_constraint,json=addCheckConstraint,proto3" json:"add_check_constraint,omitempty"`
	AddCheckConstraintUnvalidated *AddCheckConstraintUnvalidated `protobuf:"bytes,10,opt,name=add_check_constraint_unvalidated,json=addCheckConstraintUnvalidated,proto3" json:"add_check_constraint_unvalidated,omitempty"`
	DropCheckConstraint           *DropCheckConstraint           `protobuf:"bytes,11,opt,name=drop_check_constraint,json=dropCheckConstraint,proto3" json:"drop_check_constraint,omitempty"`
	AddPrimaryIndex               *AddPrimaryIndex               `protobuf:"bytes,12,opt,name=add_primary_index,json=addPrimaryIndex,proto3" json:"add_primary_index,omitempty"`
	DropPrimaryIndex              *DropPrimaryIndex              `protobuf:"bytes,13,opt,name=drop_primary_index,json=dropPrimaryIndex,proto3" json:"drop_primary_index,omitempty"`
}

func (m *TargetProto) Reset()         { *m = TargetProto{} }
func (m *TargetProto) String() string { return proto.CompactTextString(m) }
func (*TargetProto) ProtoMessage()    {}
func (*TargetProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{0}
}
func (m *TargetProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TargetProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetProto.Merge(dst, src)
}
func (m *TargetProto) XXX_Size() int {
	return m.Size()
}
func (m *TargetProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetProto.DiscardUnknown(m)
}

var xxx_messageInfo_TargetProto proto.InternalMessageInfo

type AddColumn struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	ColumnFamily github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.FamilyID `protobuf:"varint,2,opt,name=column_family,json=columnFamily,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.FamilyID" json:"column_family,omitempty"`
	Column       descpb.ColumnDescriptor                                          `protobuf:"bytes,3,opt,name=column,proto3" json:"column"`
}

func (m *AddColumn) Reset()         { *m = AddColumn{} }
func (m *AddColumn) String() string { return proto.CompactTextString(m) }
func (*AddColumn) ProtoMessage()    {}
func (*AddColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{1}
}
func (m *AddColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddColumn.Merge(dst, src)
}
func (m *AddColumn) XXX_Size() int {
	return m.Size()
}
func (m *AddColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_AddColumn.DiscardUnknown(m)
}

var xxx_messageInfo_AddColumn proto.InternalMessageInfo

type DropColumn struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Column  descpb.ColumnDescriptor                                    `protobuf:"bytes,2,opt,name=column,proto3" json:"column"`
}

func (m *DropColumn) Reset()         { *m = DropColumn{} }
func (m *DropColumn) String() string { return proto.CompactTextString(m) }
func (*DropColumn) ProtoMessage()    {}
func (*DropColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{2}
}
func (m *DropColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DropColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropColumn.Merge(dst, src)
}
func (m *DropColumn) XXX_Size() int {
	return m.Size()
}
func (m *DropColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_DropColumn.DiscardUnknown(m)
}

var xxx_messageInfo_DropColumn proto.InternalMessageInfo

type AddIndex struct {
	TableID        github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Index          descpb.IndexDescriptor                                          `protobuf:"bytes,2,opt,name=index,proto3" json:"index"`
	PrimaryIndex   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,3,opt,name=primary_index,json=primaryIndex,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"primary_index,omitempty"`
	ReplacementFor github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,4,opt,name=replacement_for,json=replacementFor,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"replacement_for,omitempty"`
}

func (m *AddIndex) Reset()         { *m = AddIndex{} }
func (m *AddIndex) String() string { return proto.CompactTextString(m) }
func (*AddIndex) ProtoMessage()    {}
func (*AddIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{3}
}
func (m *AddIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddIndex.Merge(dst, src)
}
func (m *AddIndex) XXX_Size() int {
	return m.Size()
}
func (m *AddIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AddIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AddIndex proto.InternalMessageInfo

type DropIndex struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	IndexID    github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"index_id,omitempty"`
	ReplacedBy github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,3,opt,name=replaced_by,json=replacedBy,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"replaced_by,omitempty"`
	// TODO (lucy): Replace this with the index descriptor.
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,4,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_ids,omitempty"`
}

func (m *DropIndex) Reset()         { *m = DropIndex{} }
func (m *DropIndex) String() string { return proto.CompactTextString(m) }
func (*DropIndex) ProtoMessage()    {}
func (*DropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{4}
}
func (m *DropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndex.Merge(dst, src)
}
func (m *DropIndex) XXX_Size() int {
	return m.Size()
}
func (m *DropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndex proto.InternalMessageInfo

type AddSequenceDependency struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_id,omitempty"`
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID       `protobuf:"varint,3,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"sequence_id,omitempty"`
}

func (m *AddSequenceDependency) Reset()         { *m = AddSequenceDependency{} }
func (m *AddSequenceDependency) String() string { return proto.CompactTextString(m) }
func (*AddSequenceDependency) ProtoMessage()    {}
func (*AddSequenceDependency) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{5}
}
func (m *AddSequenceDependency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddSequenceDependency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddSequenceDependency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSequenceDependency.Merge(dst, src)
}
func (m *AddSequenceDependency) XXX_Size() int {
	return m.Size()
}
func (m *AddSequenceDependency) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSequenceDependency.DiscardUnknown(m)
}

var xxx_messageInfo_AddSequenceDependency proto.InternalMessageInfo

type AddColumnFamily struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Family  descpb.ColumnFamilyDescriptor                              `protobuf:"bytes,2,opt,name=family,proto3" json:"family"`
}

func (m *AddColumnFamily) Reset()         { *m = AddColumnFamily{} }
func (m *AddColumnFamily) String() string { return proto.CompactTextString(m) }
func (*AddColumnFamily) ProtoMessage()    {}
func (*AddColumnFamily) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{6}
}
func (m *AddColumnFamily) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddColumnFamily) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddColumnFamily) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddColumnFamily.Merge(dst, src)
}
func (m *AddColumnFamily) XXX_Size() int {
	return m.Size()
}
func (m *AddColumnFamily) XXX_DiscardUnknown() {
	xxx_messageInfo_AddColumnFamily.DiscardUnknown(m)
}

var xxx_messageInfo_AddColumnFamily proto.InternalMessageInfo

type AddUniqueConstraint struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	IndexID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID    `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"index_id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_ids,omitempty"`
}

func (m *AddUniqueConstraint) Reset()         { *m = AddUniqueConstraint{} }
func (m *AddUniqueConstraint) String() string { return proto.CompactTextString(m) }
func (*AddUniqueConstraint) ProtoMessage()    {}
func (*AddUniqueConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{7}
}
func (m *AddUniqueConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddUniqueConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddUniqueConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUniqueConstraint.Merge(dst, src)
}
func (m *AddUniqueConstraint) XXX_Size() int {
	return m.Size()
}
func (m *AddUniqueConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUniqueConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_AddUniqueConstraint proto.InternalMessageInfo

type DropUniqueConstraint struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	IndexID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID    `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"index_id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_ids,omitempty"`
}

func (m *DropUniqueConstraint) Reset()         { *m = DropUniqueConstraint{} }
func (m *DropUniqueConstraint) String() string { return proto.CompactTextString(m) }
func (*DropUniqueConstraint) ProtoMessage()    {}
func (*DropUniqueConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{8}
}
func (m *DropUniqueConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropUniqueConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DropUniqueConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropUniqueConstraint.Merge(dst, src)
}
func (m *DropUniqueConstraint) XXX_Size() int {
	return m.Size()
}
func (m *DropUniqueConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_DropUniqueConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_DropUniqueConstraint proto.InternalMessageInfo

type AddCheckConstraint struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Name      string                                                             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Expr      string                                                             `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,4,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_ids,omitempty"`
}

func (m *AddCheckConstraint) Reset()         { *m = AddCheckConstraint{} }
func (m *AddCheckConstraint) String() string { return proto.CompactTextString(m) }
func (*AddCheckConstraint) ProtoMessage()    {}
func (*AddCheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{9}
}
func (m *AddCheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddCheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddCheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCheckConstraint.Merge(dst, src)
}
func (m *AddCheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *AddCheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_AddCheckConstraint proto.InternalMessageInfo

type AddCheckConstraintUnvalidated struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Name      string                                                             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Expr      string                                                             `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,4,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_ids,omitempty"`
}

func (m *AddCheckConstraintUnvalidated) Reset()         { *m = AddCheckConstraintUnvalidated{} }
func (m *AddCheckConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*AddCheckConstraintUnvalidated) ProtoMessage()    {}
func (*AddCheckConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{10}
}
func (m *AddCheckConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddCheckConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddCheckConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCheckConstraintUnvalidated.Merge(dst, src)
}
func (m *AddCheckConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *AddCheckConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCheckConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_AddCheckConstraintUnvalidated proto.InternalMessageInfo

type DropCheckConstraint struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Name    string                                                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *DropCheckConstraint) Reset()         { *m = DropCheckConstraint{} }
func (m *DropCheckConstraint) String() string { return proto.CompactTextString(m) }
func (*DropCheckConstraint) ProtoMessage()    {}
func (*DropCheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{11}
}
func (m *DropCheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropCheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DropCheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropCheckConstraint.Merge(dst, src)
}
func (m *DropCheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *DropCheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_DropCheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_DropCheckConstraint proto.InternalMessageInfo

type AddPrimaryIndex struct {
	TableID          github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Index            descpb.IndexDescriptor                                             `protobuf:"bytes,2,opt,name=index,proto3" json:"index"`
	PrimaryIndex     github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID    `protobuf:"varint,3,opt,name=primary_index,json=primaryIndex,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"primary_index,omitempty"`
	ReplacementFor   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID    `protobuf:"varint,4,opt,name=replacement_for,json=replacementFor,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"replacement_for,omitempty"`
	StoreColumnIDs   []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,5,rep,packed,name=store_column_ids,json=storeColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"store_column_ids,omitempty"`
	StoreColumnNames []string                                                           `protobuf:"bytes,6,rep,name=store_column_names,json=storeColumnNames,proto3" json:"store_column_names,omitempty"`
}

func (m *AddPrimaryIndex) Reset()         { *m = AddPrimaryIndex{} }
func (m *AddPrimaryIndex) String() string { return proto.CompactTextString(m) }
func (*AddPrimaryIndex) ProtoMessage()    {}
func (*AddPrimaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{12}
}
func (m *AddPrimaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPrimaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AddPrimaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPrimaryIndex.Merge(dst, src)
}
func (m *AddPrimaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *AddPrimaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPrimaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AddPrimaryIndex proto.InternalMessageInfo

type DropPrimaryIndex struct {
	TableID          github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id,omitempty"`
	Index            descpb.IndexDescriptor                                             `protobuf:"bytes,2,opt,name=index,proto3" json:"index"`
	ReplacedBy       github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID    `protobuf:"varint,3,opt,name=replaced_by,json=replacedBy,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"replaced_by,omitempty"`
	StoreColumnIDs   []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,4,rep,packed,name=store_column_ids,json=storeColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"store_column_ids,omitempty"`
	StoreColumnNames []string                                                           `protobuf:"bytes,5,rep,name=store_column_names,json=storeColumnNames,proto3" json:"store_column_names,omitempty"`
}

func (m *DropPrimaryIndex) Reset()         { *m = DropPrimaryIndex{} }
func (m *DropPrimaryIndex) String() string { return proto.CompactTextString(m) }
func (*DropPrimaryIndex) ProtoMessage()    {}
func (*DropPrimaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_targets_7273a5f601bca2d2, []int{13}
}
func (m *DropPrimaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropPrimaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DropPrimaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropPrimaryIndex.Merge(dst, src)
}
func (m *DropPrimaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *DropPrimaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropPrimaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropPrimaryIndex proto.InternalMessageInfo

func init() {
	proto.RegisterType((*TargetProto)(nil), "cockroach.sql.schemachanger.targets.TargetProto")
	proto.RegisterType((*AddColumn)(nil), "cockroach.sql.schemachanger.targets.AddColumn")
	proto.RegisterType((*DropColumn)(nil), "cockroach.sql.schemachanger.targets.DropColumn")
	proto.RegisterType((*AddIndex)(nil), "cockroach.sql.schemachanger.targets.AddIndex")
	proto.RegisterType((*DropIndex)(nil), "cockroach.sql.schemachanger.targets.DropIndex")
	proto.RegisterType((*AddSequenceDependency)(nil), "cockroach.sql.schemachanger.targets.AddSequenceDependency")
	proto.RegisterType((*AddColumnFamily)(nil), "cockroach.sql.schemachanger.targets.AddColumnFamily")
	proto.RegisterType((*AddUniqueConstraint)(nil), "cockroach.sql.schemachanger.targets.AddUniqueConstraint")
	proto.RegisterType((*DropUniqueConstraint)(nil), "cockroach.sql.schemachanger.targets.DropUniqueConstraint")
	proto.RegisterType((*AddCheckConstraint)(nil), "cockroach.sql.schemachanger.targets.AddCheckConstraint")
	proto.RegisterType((*AddCheckConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.targets.AddCheckConstraintUnvalidated")
	proto.RegisterType((*DropCheckConstraint)(nil), "cockroach.sql.schemachanger.targets.DropCheckConstraint")
	proto.RegisterType((*AddPrimaryIndex)(nil), "cockroach.sql.schemachanger.targets.AddPrimaryIndex")
	proto.RegisterType((*DropPrimaryIndex)(nil), "cockroach.sql.schemachanger.targets.DropPrimaryIndex")
	proto.RegisterEnum("cockroach.sql.schemachanger.targets.State", State_name, State_value)
}
func (this *AddColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddColumn)
	if !ok {
		that2, ok := that.(AddColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnFamily != that1.ColumnFamily {
		return false
	}
	if !this.Column.Equal(&that1.Column) {
		return false
	}
	return true
}
func (this *DropColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropColumn)
	if !ok {
		that2, ok := that.(DropColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.Column.Equal(&that1.Column) {
		return false
	}
	return true
}
func (this *AddIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddIndex)
	if !ok {
		that2, ok := that.(AddIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if this.PrimaryIndex != that1.PrimaryIndex {
		return false
	}
	if this.ReplacementFor != that1.ReplacementFor {
		return false
	}
	return true
}
func (this *DropIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropIndex)
	if !ok {
		that2, ok := that.(DropIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.ReplacedBy != that1.ReplacedBy {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *AddSequenceDependency) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddSequenceDependency)
	if !ok {
		that2, ok := that.(AddSequenceDependency)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	return true
}
func (this *AddColumnFamily) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddColumnFamily)
	if !ok {
		that2, ok := that.(AddColumnFamily)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.Family.Equal(&that1.Family) {
		return false
	}
	return true
}
func (this *AddUniqueConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddUniqueConstraint)
	if !ok {
		that2, ok := that.(AddUniqueConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *DropUniqueConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropUniqueConstraint)
	if !ok {
		that2, ok := that.(DropUniqueConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *AddCheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddCheckConstraint)
	if !ok {
		that2, ok := that.(AddCheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *AddCheckConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddCheckConstraintUnvalidated)
	if !ok {
		that2, ok := that.(AddCheckConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *DropCheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropCheckConstraint)
	if !ok {
		that2, ok := that.(DropCheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *AddPrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddPrimaryIndex)
	if !ok {
		that2, ok := that.(AddPrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if this.PrimaryIndex != that1.PrimaryIndex {
		return false
	}
	if this.ReplacementFor != that1.ReplacementFor {
		return false
	}
	if len(this.StoreColumnIDs) != len(that1.StoreColumnIDs) {
		return false
	}
	for i := range this.StoreColumnIDs {
		if this.StoreColumnIDs[i] != that1.StoreColumnIDs[i] {
			return false
		}
	}
	if len(this.StoreColumnNames) != len(that1.StoreColumnNames) {
		return false
	}
	for i := range this.StoreColumnNames {
		if this.StoreColumnNames[i] != that1.StoreColumnNames[i] {
			return false
		}
	}
	return true
}
func (this *DropPrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropPrimaryIndex)
	if !ok {
		that2, ok := that.(DropPrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if this.ReplacedBy != that1.ReplacedBy {
		return false
	}
	if len(this.StoreColumnIDs) != len(that1.StoreColumnIDs) {
		return false
	}
	for i := range this.StoreColumnIDs {
		if this.StoreColumnIDs[i] != that1.StoreColumnIDs[i] {
			return false
		}
	}
	if len(this.StoreColumnNames) != len(that1.StoreColumnNames) {
		return false
	}
	for i := range this.StoreColumnNames {
		if this.StoreColumnNames[i] != that1.StoreColumnNames[i] {
			return false
		}
	}
	return true
}
func (m *TargetProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddColumn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddColumn.Size()))
		n1, err := m.AddColumn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DropColumn != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.DropColumn.Size()))
		n2, err := m.DropColumn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.AddIndex != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddIndex.Size()))
		n3, err := m.AddIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DropIndex != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.DropIndex.Size()))
		n4, err := m.DropIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.AddSequenceDependency != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddSequenceDependency.Size()))
		n5, err := m.AddSequenceDependency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AddColumnFamilyDependency != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddColumnFamilyDependency.Size()))
		n6, err := m.AddColumnFamilyDependency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.AddUniqueConstraint != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddUniqueConstraint.Size()))
		n7, err := m.AddUniqueConstraint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.DropUniqueConstraint != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.DropUniqueConstraint.Size()))
		n8, err := m.DropUniqueConstraint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.AddCheckConstraint != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddCheckConstraint.Size()))
		n9, err := m.AddCheckConstraint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.AddCheckConstraintUnvalidated != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddCheckConstraintUnvalidated.Size()))
		n10, err := m.AddCheckConstraintUnvalidated.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DropCheckConstraint != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.DropCheckConstraint.Size()))
		n11, err := m.DropCheckConstraint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.AddPrimaryIndex != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.AddPrimaryIndex.Size()))
		n12, err := m.AddPrimaryIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.DropPrimaryIndex != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.DropPrimaryIndex.Size()))
		n13, err := m.DropPrimaryIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *AddColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddColumn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if m.ColumnFamily != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.ColumnFamily))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTargets(dAtA, i, uint64(m.Column.Size()))
	n14, err := m.Column.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *DropColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropColumn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintTargets(dAtA, i, uint64(m.Column.Size()))
	n15, err := m.Column.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *AddIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintTargets(dAtA, i, uint64(m.Index.Size()))
	n16, err := m.Index.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if m.PrimaryIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.PrimaryIndex))
	}
	if m.ReplacementFor != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.ReplacementFor))
	}
	return i, nil
}

func (m *DropIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if m.IndexID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.IndexID))
	}
	if m.ReplacedBy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.ReplacedBy))
	}
	if len(m.ColumnIDs) > 0 {
		dAtA18 := make([]byte, len(m.ColumnIDs)*10)
		var j17 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *AddSequenceDependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddSequenceDependency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.ColumnID))
	}
	if m.SequenceID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.SequenceID))
	}
	return i, nil
}

func (m *AddColumnFamily) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddColumnFamily) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintTargets(dAtA, i, uint64(m.Family.Size()))
	n19, err := m.Family.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	return i, nil
}

func (m *AddUniqueConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUniqueConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if m.IndexID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		dAtA21 := make([]byte, len(m.ColumnIDs)*10)
		var j20 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	return i, nil
}

func (m *DropUniqueConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropUniqueConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if m.IndexID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		dAtA23 := make([]byte, len(m.ColumnIDs)*10)
		var j22 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	return i, nil
}

func (m *AddCheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTargets(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Expr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(len(m.Expr)))
		i += copy(dAtA[i:], m.Expr)
	}
	if len(m.ColumnIDs) > 0 {
		dAtA25 := make([]byte, len(m.ColumnIDs)*10)
		var j24 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	return i, nil
}

func (m *AddCheckConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCheckConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTargets(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Expr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(len(m.Expr)))
		i += copy(dAtA[i:], m.Expr)
	}
	if len(m.ColumnIDs) > 0 {
		dAtA27 := make([]byte, len(m.ColumnIDs)*10)
		var j26 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	return i, nil
}

func (m *DropCheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropCheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTargets(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *AddPrimaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintTargets(dAtA, i, uint64(m.Index.Size()))
	n28, err := m.Index.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	if m.PrimaryIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.PrimaryIndex))
	}
	if m.ReplacementFor != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.ReplacementFor))
	}
	if len(m.StoreColumnIDs) > 0 {
		dAtA30 := make([]byte, len(m.StoreColumnIDs)*10)
		var j29 int
		for _, num := range m.StoreColumnIDs {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DropPrimaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropPrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.TableID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintTargets(dAtA, i, uint64(m.Index.Size()))
	n31, err := m.Index.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	if m.ReplacedBy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTargets(dAtA, i, uint64(m.ReplacedBy))
	}
	if len(m.StoreColumnIDs) > 0 {
		dAtA33 := make([]byte, len(m.StoreColumnIDs)*10)
		var j32 int
		for _, num := range m.StoreColumnIDs {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTargets(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintTargets(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TargetProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddColumn != nil {
		l = m.AddColumn.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.DropColumn != nil {
		l = m.DropColumn.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddIndex != nil {
		l = m.AddIndex.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.DropIndex != nil {
		l = m.DropIndex.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddSequenceDependency != nil {
		l = m.AddSequenceDependency.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddColumnFamilyDependency != nil {
		l = m.AddColumnFamilyDependency.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddUniqueConstraint != nil {
		l = m.AddUniqueConstraint.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.DropUniqueConstraint != nil {
		l = m.DropUniqueConstraint.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddCheckConstraint != nil {
		l = m.AddCheckConstraint.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddCheckConstraintUnvalidated != nil {
		l = m.AddCheckConstraintUnvalidated.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.DropCheckConstraint != nil {
		l = m.DropCheckConstraint.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.AddPrimaryIndex != nil {
		l = m.AddPrimaryIndex.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	if m.DropPrimaryIndex != nil {
		l = m.DropPrimaryIndex.Size()
		n += 1 + l + sovTargets(uint64(l))
	}
	return n
}

func (m *AddColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	if m.ColumnFamily != 0 {
		n += 1 + sovTargets(uint64(m.ColumnFamily))
	}
	l = m.Column.Size()
	n += 1 + l + sovTargets(uint64(l))
	return n
}

func (m *DropColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = m.Column.Size()
	n += 1 + l + sovTargets(uint64(l))
	return n
}

func (m *AddIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = m.Index.Size()
	n += 1 + l + sovTargets(uint64(l))
	if m.PrimaryIndex != 0 {
		n += 1 + sovTargets(uint64(m.PrimaryIndex))
	}
	if m.ReplacementFor != 0 {
		n += 1 + sovTargets(uint64(m.ReplacementFor))
	}
	return n
}

func (m *DropIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovTargets(uint64(m.IndexID))
	}
	if m.ReplacedBy != 0 {
		n += 1 + sovTargets(uint64(m.ReplacedBy))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	return n
}

func (m *AddSequenceDependency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovTargets(uint64(m.ColumnID))
	}
	if m.SequenceID != 0 {
		n += 1 + sovTargets(uint64(m.SequenceID))
	}
	return n
}

func (m *AddColumnFamily) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = m.Family.Size()
	n += 1 + l + sovTargets(uint64(l))
	return n
}

func (m *AddUniqueConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovTargets(uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	return n
}

func (m *DropUniqueConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovTargets(uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	return n
}

func (m *AddCheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTargets(uint64(l))
	}
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovTargets(uint64(l))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	return n
}

func (m *AddCheckConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTargets(uint64(l))
	}
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovTargets(uint64(l))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	return n
}

func (m *DropCheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTargets(uint64(l))
	}
	return n
}

func (m *AddPrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = m.Index.Size()
	n += 1 + l + sovTargets(uint64(l))
	if m.PrimaryIndex != 0 {
		n += 1 + sovTargets(uint64(m.PrimaryIndex))
	}
	if m.ReplacementFor != 0 {
		n += 1 + sovTargets(uint64(m.ReplacementFor))
	}
	if len(m.StoreColumnIDs) > 0 {
		l = 0
		for _, e := range m.StoreColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			l = len(s)
			n += 1 + l + sovTargets(uint64(l))
		}
	}
	return n
}

func (m *DropPrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTargets(uint64(m.TableID))
	}
	l = m.Index.Size()
	n += 1 + l + sovTargets(uint64(l))
	if m.ReplacedBy != 0 {
		n += 1 + sovTargets(uint64(m.ReplacedBy))
	}
	if len(m.StoreColumnIDs) > 0 {
		l = 0
		for _, e := range m.StoreColumnIDs {
			l += sovTargets(uint64(e))
		}
		n += 1 + sovTargets(uint64(l)) + l
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			l = len(s)
			n += 1 + l + sovTargets(uint64(l))
		}
	}
	return n
}

func sovTargets(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTargets(x uint64) (n int) {
	return sovTargets(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TargetProto) GetValue() interface{} {
	if this.AddColumn != nil {
		return this.AddColumn
	}
	if this.DropColumn != nil {
		return this.DropColumn
	}
	if this.AddIndex != nil {
		return this.AddIndex
	}
	if this.DropIndex != nil {
		return this.DropIndex
	}
	if this.AddSequenceDependency != nil {
		return this.AddSequenceDependency
	}
	if this.AddColumnFamilyDependency != nil {
		return this.AddColumnFamilyDependency
	}
	if this.AddUniqueConstraint != nil {
		return this.AddUniqueConstraint
	}
	if this.DropUniqueConstraint != nil {
		return this.DropUniqueConstraint
	}
	if this.AddCheckConstraint != nil {
		return this.AddCheckConstraint
	}
	if this.AddCheckConstraintUnvalidated != nil {
		return this.AddCheckConstraintUnvalidated
	}
	if this.DropCheckConstraint != nil {
		return this.DropCheckConstraint
	}
	if this.AddPrimaryIndex != nil {
		return this.AddPrimaryIndex
	}
	if this.DropPrimaryIndex != nil {
		return this.DropPrimaryIndex
	}
	return nil
}

func (this *TargetProto) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *AddColumn:
		this.AddColumn = vt
	case *DropColumn:
		this.DropColumn = vt
	case *AddIndex:
		this.AddIndex = vt
	case *DropIndex:
		this.DropIndex = vt
	case *AddSequenceDependency:
		this.AddSequenceDependency = vt
	case *AddColumnFamily:
		this.AddColumnFamilyDependency = vt
	case *AddUniqueConstraint:
		this.AddUniqueConstraint = vt
	case *DropUniqueConstraint:
		this.DropUniqueConstraint = vt
	case *AddCheckConstraint:
		this.AddCheckConstraint = vt
	case *AddCheckConstraintUnvalidated:
		this.AddCheckConstraintUnvalidated = vt
	case *DropCheckConstraint:
		this.DropCheckConstraint = vt
	case *AddPrimaryIndex:
		this.AddPrimaryIndex = vt
	case *DropPrimaryIndex:
		this.DropPrimaryIndex = vt
	default:
		return false
	}
	return true
}
func (m *TargetProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddColumn == nil {
				m.AddColumn = &AddColumn{}
			}
			if err := m.AddColumn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropColumn == nil {
				m.DropColumn = &DropColumn{}
			}
			if err := m.DropColumn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddIndex == nil {
				m.AddIndex = &AddIndex{}
			}
			if err := m.AddIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropIndex == nil {
				m.DropIndex = &DropIndex{}
			}
			if err := m.DropIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSequenceDependency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddSequenceDependency == nil {
				m.AddSequenceDependency = &AddSequenceDependency{}
			}
			if err := m.AddSequenceDependency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddColumnFamilyDependency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddColumnFamilyDependency == nil {
				m.AddColumnFamilyDependency = &AddColumnFamily{}
			}
			if err := m.AddColumnFamilyDependency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddUniqueConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddUniqueConstraint == nil {
				m.AddUniqueConstraint = &AddUniqueConstraint{}
			}
			if err := m.AddUniqueConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropUniqueConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropUniqueConstraint == nil {
				m.DropUniqueConstraint = &DropUniqueConstraint{}
			}
			if err := m.DropUniqueConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddCheckConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddCheckConstraint == nil {
				m.AddCheckConstraint = &AddCheckConstraint{}
			}
			if err := m.AddCheckConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddCheckConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddCheckConstraintUnvalidated == nil {
				m.AddCheckConstraintUnvalidated = &AddCheckConstraintUnvalidated{}
			}
			if err := m.AddCheckConstraintUnvalidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCheckConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropCheckConstraint == nil {
				m.DropCheckConstraint = &DropCheckConstraint{}
			}
			if err := m.DropCheckConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddPrimaryIndex == nil {
				m.AddPrimaryIndex = &AddPrimaryIndex{}
			}
			if err := m.AddPrimaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropPrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropPrimaryIndex == nil {
				m.DropPrimaryIndex = &DropPrimaryIndex{}
			}
			if err := m.DropPrimaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnFamily", wireType)
			}
			m.ColumnFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnFamily |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.FamilyID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			m.PrimaryIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryIndex |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacementFor", wireType)
			}
			m.ReplacementFor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplacementFor |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacedBy", wireType)
			}
			m.ReplacedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplacedBy |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddSequenceDependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSequenceDependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSequenceDependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddColumnFamily) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddColumnFamily: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddColumnFamily: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Family.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUniqueConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUniqueConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUniqueConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropUniqueConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropUniqueConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropUniqueConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCheckConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCheckConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCheckConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropCheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropCheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropCheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPrimaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPrimaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPrimaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			m.PrimaryIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryIndex |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacementFor", wireType)
			}
			m.ReplacementFor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplacementFor |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoreColumnIDs = append(m.StoreColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoreColumnIDs) == 0 {
					m.StoreColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoreColumnIDs = append(m.StoreColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnIDs", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreColumnNames = append(m.StoreColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropPrimaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropPrimaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropPrimaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacedBy", wireType)
			}
			m.ReplacedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplacedBy |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoreColumnIDs = append(m.StoreColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTargets
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoreColumnIDs) == 0 {
					m.StoreColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTargets
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoreColumnIDs = append(m.StoreColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnIDs", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTargets
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreColumnNames = append(m.StoreColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTargets(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTargets
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTargets(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTargets
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTargets
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTargets
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTargets
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTargets(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTargets = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTargets   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/schemachanger/targets/targets.proto", fileDescriptor_targets_7273a5f601bca2d2)
}

var fileDescriptor_targets_7273a5f601bca2d2 = []byte{
	// 1216 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xbd, 0x6f, 0x23, 0x45,
	0x14, 0xf7, 0xfa, 0x7b, 0x9f, 0xcf, 0x89, 0x99, 0xe4, 0xc0, 0x77, 0xe2, 0xec, 0xe8, 0x4e, 0xe2,
	0x02, 0x12, 0xb6, 0xc4, 0x87, 0x80, 0x34, 0xe0, 0xcd, 0x3a, 0xd2, 0x12, 0xe3, 0x0b, 0x9b, 0xe4,
	0x4e, 0xd0, 0x2c, 0xe3, 0x9d, 0x39, 0x7b, 0x15, 0x7b, 0x77, 0xb3, 0xbb, 0x86, 0x4b, 0x47, 0x4f,
	0x83, 0x90, 0x68, 0xa8, 0x68, 0x28, 0xf8, 0x17, 0x68, 0x28, 0x89, 0xa8, 0xae, 0xbc, 0xca, 0xdc,
	0x39, 0x0d, 0x1d, 0xfd, 0x55, 0x68, 0x66, 0x77, 0x1d, 0x7f, 0x71, 0x72, 0x12, 0xcb, 0x01, 0x94,
	0x2a, 0xa3, 0xb7, 0x99, 0xdf, 0xef, 0xf7, 0xde, 0x9b, 0xf7, 0xe6, 0x8d, 0xe1, 0xae, 0x7b, 0xd8,
	0x2e, 0xbb, 0x7a, 0x8b, 0x76, 0xb0, 0xde, 0xc2, 0x66, 0x93, 0x3a, 0x65, 0x0f, 0x3b, 0x4d, 0xea,
	0xb9, 0xe1, 0xdf, 0x92, 0xed, 0x58, 0x9e, 0x85, 0xee, 0xe8, 0x96, 0x7e, 0xe0, 0x58, 0x58, 0x6f,
	0x95, 0xdc, 0xc3, 0x76, 0x69, 0x64, 0x4b, 0x29, 0xf8, 0xd7, 0x9b, 0x77, 0x18, 0x9a, 0x8e, 0x3d,
	0xdc, 0xb6, 0x9a, 0x65, 0x42, 0x5d, 0xdd, 0x6e, 0x94, 0x5d, 0xcf, 0xe9, 0xea, 0x5e, 0xd7, 0xa1,
	0xc4, 0x47, 0xba, 0xb9, 0xda, 0xb4, 0x9a, 0x16, 0x5f, 0x96, 0xd9, 0xca, 0xb7, 0xde, 0xfe, 0x0d,
	0x20, 0xb3, 0xc7, 0x61, 0x76, 0x38, 0xdf, 0x27, 0x00, 0x98, 0x10, 0x4d, 0xb7, 0xda, 0xdd, 0x8e,
	0x99, 0x17, 0xd6, 0x84, 0xf5, 0xcc, 0x5b, 0xa5, 0xd2, 0x0c, 0x22, 0x4a, 0x15, 0x42, 0x36, 0xf9,
	0x2e, 0x55, 0xc4, 0xe1, 0x12, 0xed, 0x40, 0x86, 0x38, 0x96, 0x1d, 0xe2, 0x45, 0x39, 0x5e, 0x79,
	0x26, 0x3c, 0xd9, 0xb1, 0xec, 0x00, 0x10, 0xc8, 0x60, 0x8d, 0x3e, 0x06, 0x06, 0xaf, 0x19, 0x26,
	0xa1, 0x8f, 0xf2, 0x31, 0x8e, 0xf7, 0xe6, 0xac, 0xfa, 0x14, 0xb6, 0x49, 0x4d, 0xe3, 0x60, 0xc5,
	0x9c, 0xe5, 0xea, 0x7c, 0xb0, 0xf8, 0x19, 0x9c, 0x65, 0xe2, 0x7c, 0x34, 0x91, 0x84, 0x4b, 0xe4,
	0xc0, 0x2b, 0x4c, 0x9a, 0x4b, 0x0f, 0xbb, 0xd4, 0xd4, 0xa9, 0x46, 0xa8, 0x4d, 0x4d, 0x42, 0x4d,
	0xfd, 0x28, 0x9f, 0xe0, 0xd8, 0x1b, 0xb3, 0x0a, 0xdd, 0x0d, 0x20, 0xe4, 0x01, 0x82, 0x7a, 0x1d,
	0x4f, 0x33, 0xa3, 0x2e, 0xbc, 0x7a, 0x9a, 0x2f, 0xed, 0x21, 0xee, 0x18, 0xed, 0xa3, 0x61, 0xe2,
	0x24, 0x27, 0x7e, 0xe7, 0x6c, 0x19, 0xdc, 0xe2, 0x30, 0xea, 0x0d, 0x3c, 0x6a, 0x18, 0xa2, 0x6d,
	0x03, 0xd3, 0xa3, 0x75, 0x4d, 0xe3, 0xb0, 0x4b, 0x35, 0xdd, 0x32, 0x5d, 0xcf, 0xc1, 0x86, 0xe9,
	0xe5, 0x53, 0x9c, 0xef, 0xfd, 0x59, 0xf9, 0xf6, 0x39, 0xc0, 0xe6, 0x60, 0xbf, 0xba, 0x82, 0x27,
	0x8d, 0xc8, 0x82, 0x97, 0x79, 0x9e, 0x26, 0xe9, 0xd2, 0x9c, 0xee, 0x83, 0x99, 0x73, 0x36, 0xc1,
	0xb7, 0x4a, 0xa6, 0x58, 0x91, 0x01, 0xab, 0x3c, 0xaa, 0x2d, 0xaa, 0x1f, 0x0c, 0xd3, 0x89, 0x9c,
	0xee, 0xbd, 0x99, 0xa3, 0xc9, 0xf6, 0x0f, 0x91, 0x21, 0x3c, 0x61, 0x43, 0xdf, 0x08, 0xb0, 0x36,
	0x8d, 0x4b, 0xeb, 0x9a, 0x5f, 0xe2, 0xb6, 0x41, 0xb0, 0x47, 0x49, 0x1e, 0x38, 0xaf, 0x74, 0x4e,
	0xde, 0xfd, 0x53, 0x24, 0xf5, 0x16, 0x7e, 0xd1, 0x67, 0x96, 0x57, 0xbf, 0x5e, 0xc7, 0x3d, 0xcf,
	0x9c, 0x21, 0xaf, 0xbc, 0x72, 0xc7, 0x5c, 0x5f, 0x21, 0x93, 0x46, 0xf4, 0x05, 0xbc, 0xc4, 0x5c,
	0xb7, 0x1d, 0xa3, 0x83, 0x9d, 0xa3, 0xa0, 0x0c, 0xaf, 0x9d, 0xed, 0xc4, 0xee, 0xf8, 0x9b, 0xfd,
	0x62, 0x5c, 0xc6, 0xa3, 0x06, 0xa4, 0x03, 0xe2, 0xfe, 0x8c, 0x52, 0x64, 0x39, 0xc5, 0xbb, 0x33,
	0x3b, 0x33, 0xc2, 0x91, 0x23, 0x63, 0x96, 0x8d, 0xf8, 0xf1, 0x8f, 0x45, 0xe1, 0xf6, 0xcf, 0x51,
	0x10, 0x07, 0x15, 0x84, 0x08, 0xa4, 0x3d, 0xdc, 0x68, 0x53, 0xcd, 0x20, 0xbc, 0x8b, 0x66, 0x25,
	0xa5, 0xdf, 0x2b, 0xa6, 0xf6, 0x98, 0x4d, 0x91, 0x9f, 0xf7, 0x8a, 0x1b, 0x4d, 0xc3, 0x6b, 0x75,
	0x1b, 0x25, 0xdd, 0xea, 0x94, 0x07, 0x3a, 0x48, 0xe3, 0x74, 0x5d, 0xb6, 0x0f, 0x9a, 0xe5, 0xc9,
	0xc6, 0x5e, 0x52, 0x64, 0x35, 0xc5, 0xa1, 0x15, 0x82, 0x0c, 0xc8, 0x8e, 0x54, 0x3e, 0x6f, 0xb0,
	0x59, 0x89, 0xe1, 0x7f, 0x74, 0x5e, 0x7c, 0xbf, 0xd6, 0x15, 0x59, 0xbd, 0xa6, 0x0f, 0xd5, 0x3e,
	0xaa, 0x42, 0x32, 0x68, 0xe2, 0x7e, 0xd3, 0xbd, 0x3b, 0x1e, 0xbd, 0xc3, 0x76, 0x03, 0xbb, 0xb4,
	0xe4, 0xfb, 0x2f, 0x53, 0x57, 0x77, 0x0c, 0xdb, 0xb3, 0x1c, 0x29, 0x7e, 0xdc, 0x2b, 0x46, 0xd4,
	0x60, 0xf3, 0x46, 0xfc, 0x4f, 0x16, 0xab, 0x5f, 0x05, 0x80, 0xd3, 0xfe, 0xbe, 0xa0, 0x60, 0x9d,
	0x7a, 0x10, 0xbd, 0xb8, 0x07, 0xdf, 0xc5, 0x20, 0x1d, 0xde, 0x28, 0x0b, 0xd2, 0x2f, 0x41, 0xc2,
	0x3f, 0xbe, 0xbe, 0xfc, 0xd7, 0xfe, 0x41, 0x3e, 0x97, 0x34, 0xa1, 0xde, 0xdf, 0x8a, 0x5a, 0x90,
	0x1d, 0x2d, 0x85, 0x18, 0x97, 0xbb, 0xf9, 0xbc, 0x57, 0xfc, 0xf0, 0xdc, 0x1a, 0x19, 0x10, 0x3b,
	0x2f, 0xf6, 0x70, 0xe5, 0xb5, 0x61, 0xd9, 0xa1, 0x76, 0x1b, 0xeb, 0xb4, 0x43, 0x4d, 0x4f, 0x7b,
	0x68, 0x39, 0xfc, 0x82, 0x9d, 0x13, 0xd7, 0xd2, 0x10, 0xf6, 0x96, 0xe5, 0x04, 0x49, 0xf9, 0x25,
	0x06, 0xe2, 0xe0, 0x66, 0x5e, 0x58, 0x09, 0xa6, 0x79, 0x24, 0x19, 0x8b, 0x5f, 0x7d, 0x75, 0xc6,
	0x12, 0x08, 0x9d, 0x87, 0xaf, 0x29, 0x8e, 0xaf, 0x10, 0x44, 0x20, 0x13, 0xb8, 0x4d, 0xb4, 0xc6,
	0xd1, 0x3c, 0x53, 0x07, 0x21, 0xae, 0x74, 0x84, 0x6c, 0x80, 0xa0, 0xa7, 0x18, 0xc4, 0xcd, 0xc7,
	0xd7, 0x62, 0xeb, 0x59, 0xe9, 0xd3, 0x7e, 0xaf, 0x28, 0xfa, 0x75, 0xa1, 0xc8, 0xee, 0x45, 0xba,
	0x4b, 0x08, 0xa2, 0x8a, 0x3e, 0x89, 0x42, 0xdc, 0x20, 0x79, 0xcf, 0xa2, 0x70, 0x7d, 0xea, 0xe8,
	0xb3, 0xa0, 0x44, 0x76, 0x40, 0x1c, 0xf8, 0x1d, 0x64, 0x72, 0xa7, 0xdf, 0x2b, 0xa6, 0x43, 0xc5,
	0x73, 0xf1, 0x3a, 0x1d, 0x7a, 0x8d, 0x3a, 0x90, 0x19, 0x0c, 0x8a, 0x06, 0x09, 0x92, 0x59, 0xeb,
	0xf7, 0x8a, 0x10, 0x46, 0xe0, 0xc2, 0xae, 0x41, 0x48, 0xa0, 0x90, 0x20, 0xc6, 0xbf, 0x0b, 0xb0,
	0x3c, 0x36, 0xe5, 0x2d, 0x28, 0xba, 0xdb, 0x90, 0x1c, 0xba, 0xa2, 0xa6, 0xcc, 0xec, 0x23, 0xcd,
	0x37, 0x9c, 0x37, 0xc7, 0x5b, 0xb0, 0x0f, 0x11, 0x38, 0xd3, 0x8b, 0xc2, 0xca, 0x94, 0x11, 0xf2,
	0xff, 0x57, 0xf7, 0xa3, 0x15, 0x19, 0x5b, 0x58, 0x45, 0xfe, 0x11, 0x85, 0xd5, 0x69, 0x43, 0xf3,
	0x55, 0x84, 0xe7, 0x15, 0xe1, 0x1f, 0xa2, 0x80, 0x26, 0xe7, 0xf5, 0x05, 0xc5, 0x17, 0x41, 0xdc,
	0xc4, 0x1d, 0xca, 0x63, 0x2b, 0xaa, 0x7c, 0xcd, 0x6c, 0xf4, 0x91, 0xed, 0xf0, 0x76, 0x24, 0xaa,
	0x7c, 0x7d, 0x69, 0x17, 0xc2, 0x4f, 0x51, 0xb8, 0xf5, 0xc2, 0xc7, 0xcc, 0x55, 0x9c, 0x78, 0x9c,
	0xbe, 0x17, 0x60, 0x65, 0xca, 0x93, 0xeb, 0xf2, 0xa2, 0x13, 0xe8, 0x7a, 0x1a, 0xe7, 0x97, 0xcd,
	0xc8, 0x7b, 0xec, 0x6a, 0x52, 0xbe, 0xe4, 0x49, 0x19, 0x7d, 0x2d, 0x40, 0xce, 0xf5, 0x2c, 0x87,
	0x6a, 0x43, 0x87, 0x35, 0xc1, 0x0f, 0xeb, 0xfd, 0x7e, 0xaf, 0xb8, 0xb4, 0xcb, 0xbe, 0xcd, 0xf7,
	0xc4, 0x2e, 0xb9, 0x43, 0x98, 0xc4, 0x45, 0x12, 0xa0, 0x11, 0x05, 0xec, 0xcc, 0xb8, 0xf9, 0xe4,
	0x5a, 0x6c, 0x5d, 0x94, 0x56, 0xfb, 0xbd, 0x62, 0x6e, 0x48, 0x43, 0x9d, 0x7d, 0x53, 0x73, 0xee,
	0x98, 0x25, 0x38, 0x62, 0x7f, 0xc5, 0x20, 0x37, 0xfe, 0x40, 0xff, 0x0f, 0x9d, 0xb1, 0xc5, 0x0c,
	0xf4, 0x53, 0x33, 0x1e, 0xff, 0x17, 0x64, 0x3c, 0x71, 0xf6, 0x8c, 0xbf, 0xf1, 0x15, 0x24, 0x76,
	0x3d, 0xec, 0x51, 0x94, 0x81, 0xd4, 0x7e, 0x7d, 0xbb, 0x7e, 0xef, 0x41, 0x3d, 0x17, 0x41, 0x00,
	0xc9, 0x8a, 0xb4, 0x5b, 0xad, 0xef, 0xe5, 0x04, 0xb4, 0x0c, 0x19, 0xb9, 0x5a, 0xab, 0xee, 0x55,
	0xb5, 0x7b, 0xf5, 0xda, 0x67, 0xb9, 0x28, 0xba, 0x01, 0xd7, 0x03, 0x43, 0xa5, 0x2e, 0x6b, 0x0f,
	0x54, 0x25, 0xfc, 0x14, 0x43, 0x4b, 0x00, 0x52, 0x65, 0x73, 0x7b, 0x4b, 0xa9, 0xd5, 0xaa, 0x72,
	0x2e, 0x8e, 0xb2, 0x20, 0xde, 0xaf, 0xd4, 0x14, 0xb9, 0xb2, 0x57, 0x95, 0x73, 0x09, 0x06, 0xbb,
	0xb3, 0x2f, 0xd5, 0x94, 0xcd, 0x5c, 0x52, 0x7a, 0xfd, 0xf8, 0x59, 0x21, 0x72, 0xdc, 0x2f, 0x08,
	0x8f, 0xfb, 0x05, 0xe1, 0x49, 0xbf, 0x20, 0x3c, 0xed, 0x17, 0x84, 0x6f, 0x4f, 0x0a, 0x91, 0xc7,
	0x27, 0x85, 0xc8, 0x93, 0x93, 0x42, 0xe4, 0xf3, 0x54, 0xf0, 0x93, 0x51, 0x23, 0xc9, 0x7f, 0x5a,
	0x7f, 0xfb, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x62, 0xaf, 0x2f, 0xc2, 0xe5, 0x17, 0x00, 0x00,
}
