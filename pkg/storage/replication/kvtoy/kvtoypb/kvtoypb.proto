// Copyright 2019 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

syntax = "proto2";
package cockroach.roachpb;
option go_package = "kvtoypb";

import "roachpb/errors.proto";
import "roachpb/metadata.proto";
import "etcd/raft/raftpb/raft.proto";
import "gogoproto/gogo.proto";

// RaftMessageRequest is the request used to send raft messages using our
// protobuf-based RPC codec. If a RaftMessageRequest has a non-empty number of
// heartbeats or heartbeat_resps, the contents of the message field is treated
// as a dummy message and discarded. A coalesced heartbeat request's replica
// descriptor's range ID must be zero.
message RaftMessageRequest {
  optional uint64 range_id = 1 [(gogoproto.nullable) = false,
      (gogoproto.customname) = "RangeID",
      (gogoproto.casttype) = "github.com/cockroachdb/cockroach/pkg/roachpb.RangeID"];
  // Optionally, the start key of the sending replica. This is only populated
  // as a "hint" under certain conditions.
  optional bytes range_start_key = 8 [(gogoproto.casttype) = "github.com/cockroachdb/cockroach/pkg/roachpb.RKey"];

  optional roachpb.ReplicaDescriptor from_replica = 2 [(gogoproto.nullable) = false];
  optional roachpb.ReplicaDescriptor to_replica = 3 [(gogoproto.nullable) = false];

  optional raftpb.Message message = 4 [(gogoproto.nullable) = false];

  // // Is this a quiesce request? A quiesce request is a MsgHeartbeat
  // // which is requesting the recipient to stop ticking its local
  // // replica as long as the current Raft state matches the heartbeat
  // // Term/Commit. If the Term/Commit match, the recipient is marked as
  // // quiescent. If they don't match, the message is passed along to
  // // Raft which will generate a MsgHeartbeatResp that will unquiesce
  // // the sender.
  // optional bool quiesce = 5 [(gogoproto.nullable) = false];

  // // A coalesced heartbeat request is any RaftMessageRequest with a nonzero number of
  // // heartbeats or heartbeat_resps.
  // repeated RaftHeartbeat heartbeats = 6 [(gogoproto.nullable) = false];
  // repeated RaftHeartbeat heartbeat_resps = 7 [(gogoproto.nullable) = false];
}


message RaftMessageRequestBatch {
  repeated RaftMessageRequest requests = 1 [(gogoproto.nullable) = false];
}

message RaftMessageResponseUnion {
  option (gogoproto.onlyone) = true;

  optional roachpb.Error error = 1;
}


// RaftMessageResponse may be sent to the sender of a
// RaftMessageRequest. RaftMessage does not use the usual
// request/response pattern; it is primarily modeled as a one-way
// stream of requests. Normal 'responses' are usually sent as new
// requests on a separate stream in the other direction.
// RaftMessageResponse is not sent for every RaftMessageRequest, but
// may be used for certain error conditions.
message RaftMessageResponse {
  optional uint64 range_id = 1 [(gogoproto.nullable) = false,
      (gogoproto.customname) = "RangeID",
      (gogoproto.casttype) = "github.com/cockroachdb/cockroach/pkg/roachpb.RangeID"];

  optional roachpb.ReplicaDescriptor from_replica = 2 [(gogoproto.nullable) = false];
  optional roachpb.ReplicaDescriptor to_replica = 3 [(gogoproto.nullable) = false];

  optional RaftMessageResponseUnion union = 4 [(gogoproto.nullable) = false];
}

service MultiRaft {
  rpc RaftMessageBatch (stream RaftMessageRequestBatch) returns (stream RaftMessageResponse) {}

}
