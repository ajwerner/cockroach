// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/replication/kvtoy/kvtoypb/api.proto

package kvtoypb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"

import bytes "bytes"

import (
	context "context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// RequestHeader is supplied with every storage node request.
type RequestHeader struct {
	// The key for request. If the request operates on a range, this
	// represents the starting key for the range.
	Key                  github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{0}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(dst, src)
}
func (m *RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

type ResponseHeader struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{1}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(dst, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

// A RequestUnion contains exactly one of the requests.
// The values added here must match those in ResponseUnion.
//
// Be cautious about deprecating fields as doing so can lead to inconsistencies
// between replicas.
type RequestUnion struct {
	// Types that are valid to be assigned to Value:
	//	*RequestUnion_Get
	//	*RequestUnion_Put
	//	*RequestUnion_ConditionalPut
	//	*RequestUnion_Delete
	Value                isRequestUnion_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RequestUnion) Reset()         { *m = RequestUnion{} }
func (m *RequestUnion) String() string { return proto.CompactTextString(m) }
func (*RequestUnion) ProtoMessage()    {}
func (*RequestUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{2}
}
func (m *RequestUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RequestUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestUnion.Merge(dst, src)
}
func (m *RequestUnion) XXX_Size() int {
	return m.Size()
}
func (m *RequestUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestUnion.DiscardUnknown(m)
}

var xxx_messageInfo_RequestUnion proto.InternalMessageInfo

type isRequestUnion_Value interface {
	isRequestUnion_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RequestUnion_Get struct {
	Get *GetRequest `protobuf:"bytes,1,opt,name=get,proto3,oneof"`
}
type RequestUnion_Put struct {
	Put *PutRequest `protobuf:"bytes,2,opt,name=put,proto3,oneof"`
}
type RequestUnion_ConditionalPut struct {
	ConditionalPut *ConditionalPutRequest `protobuf:"bytes,3,opt,name=conditional_put,json=conditionalPut,proto3,oneof"`
}
type RequestUnion_Delete struct {
	Delete *DeleteRequest `protobuf:"bytes,5,opt,name=delete,proto3,oneof"`
}

func (*RequestUnion_Get) isRequestUnion_Value()            {}
func (*RequestUnion_Put) isRequestUnion_Value()            {}
func (*RequestUnion_ConditionalPut) isRequestUnion_Value() {}
func (*RequestUnion_Delete) isRequestUnion_Value()         {}

func (m *RequestUnion) GetValue() isRequestUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RequestUnion) GetGet() *GetRequest {
	if x, ok := m.GetValue().(*RequestUnion_Get); ok {
		return x.Get
	}
	return nil
}

func (m *RequestUnion) GetPut() *PutRequest {
	if x, ok := m.GetValue().(*RequestUnion_Put); ok {
		return x.Put
	}
	return nil
}

func (m *RequestUnion) GetConditionalPut() *ConditionalPutRequest {
	if x, ok := m.GetValue().(*RequestUnion_ConditionalPut); ok {
		return x.ConditionalPut
	}
	return nil
}

func (m *RequestUnion) GetDelete() *DeleteRequest {
	if x, ok := m.GetValue().(*RequestUnion_Delete); ok {
		return x.Delete
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RequestUnion) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RequestUnion_OneofMarshaler, _RequestUnion_OneofUnmarshaler, _RequestUnion_OneofSizer, []interface{}{
		(*RequestUnion_Get)(nil),
		(*RequestUnion_Put)(nil),
		(*RequestUnion_ConditionalPut)(nil),
		(*RequestUnion_Delete)(nil),
	}
}

func _RequestUnion_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RequestUnion)
	// value
	switch x := m.Value.(type) {
	case *RequestUnion_Get:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Get); err != nil {
			return err
		}
	case *RequestUnion_Put:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Put); err != nil {
			return err
		}
	case *RequestUnion_ConditionalPut:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConditionalPut); err != nil {
			return err
		}
	case *RequestUnion_Delete:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delete); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RequestUnion.Value has unexpected type %T", x)
	}
	return nil
}

func _RequestUnion_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RequestUnion)
	switch tag {
	case 1: // value.get
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetRequest)
		err := b.DecodeMessage(msg)
		m.Value = &RequestUnion_Get{msg}
		return true, err
	case 2: // value.put
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PutRequest)
		err := b.DecodeMessage(msg)
		m.Value = &RequestUnion_Put{msg}
		return true, err
	case 3: // value.conditional_put
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConditionalPutRequest)
		err := b.DecodeMessage(msg)
		m.Value = &RequestUnion_ConditionalPut{msg}
		return true, err
	case 5: // value.delete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteRequest)
		err := b.DecodeMessage(msg)
		m.Value = &RequestUnion_Delete{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RequestUnion_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RequestUnion)
	// value
	switch x := m.Value.(type) {
	case *RequestUnion_Get:
		s := proto.Size(x.Get)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestUnion_Put:
		s := proto.Size(x.Put)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestUnion_ConditionalPut:
		s := proto.Size(x.ConditionalPut)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestUnion_Delete:
		s := proto.Size(x.Delete)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A ResponseUnion contains exactly one of the responses.
// The values added here must match those in RequestUnion.
type ResponseUnion struct {
	// Types that are valid to be assigned to Value:
	//	*ResponseUnion_Get
	//	*ResponseUnion_Put
	//	*ResponseUnion_ConditionalPut
	//	*ResponseUnion_Delete
	Value                isResponseUnion_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ResponseUnion) Reset()         { *m = ResponseUnion{} }
func (m *ResponseUnion) String() string { return proto.CompactTextString(m) }
func (*ResponseUnion) ProtoMessage()    {}
func (*ResponseUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{3}
}
func (m *ResponseUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResponseUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseUnion.Merge(dst, src)
}
func (m *ResponseUnion) XXX_Size() int {
	return m.Size()
}
func (m *ResponseUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseUnion.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseUnion proto.InternalMessageInfo

type isResponseUnion_Value interface {
	isResponseUnion_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResponseUnion_Get struct {
	Get *GetResponse `protobuf:"bytes,1,opt,name=get,proto3,oneof"`
}
type ResponseUnion_Put struct {
	Put *PutResponse `protobuf:"bytes,2,opt,name=put,proto3,oneof"`
}
type ResponseUnion_ConditionalPut struct {
	ConditionalPut *ConditionalPutResponse `protobuf:"bytes,3,opt,name=conditional_put,json=conditionalPut,proto3,oneof"`
}
type ResponseUnion_Delete struct {
	Delete *DeleteResponse `protobuf:"bytes,5,opt,name=delete,proto3,oneof"`
}

func (*ResponseUnion_Get) isResponseUnion_Value()            {}
func (*ResponseUnion_Put) isResponseUnion_Value()            {}
func (*ResponseUnion_ConditionalPut) isResponseUnion_Value() {}
func (*ResponseUnion_Delete) isResponseUnion_Value()         {}

func (m *ResponseUnion) GetValue() isResponseUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ResponseUnion) GetGet() *GetResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Get); ok {
		return x.Get
	}
	return nil
}

func (m *ResponseUnion) GetPut() *PutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Put); ok {
		return x.Put
	}
	return nil
}

func (m *ResponseUnion) GetConditionalPut() *ConditionalPutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ConditionalPut); ok {
		return x.ConditionalPut
	}
	return nil
}

func (m *ResponseUnion) GetDelete() *DeleteResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Delete); ok {
		return x.Delete
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResponseUnion) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResponseUnion_OneofMarshaler, _ResponseUnion_OneofUnmarshaler, _ResponseUnion_OneofSizer, []interface{}{
		(*ResponseUnion_Get)(nil),
		(*ResponseUnion_Put)(nil),
		(*ResponseUnion_ConditionalPut)(nil),
		(*ResponseUnion_Delete)(nil),
	}
}

func _ResponseUnion_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResponseUnion)
	// value
	switch x := m.Value.(type) {
	case *ResponseUnion_Get:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Get); err != nil {
			return err
		}
	case *ResponseUnion_Put:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Put); err != nil {
			return err
		}
	case *ResponseUnion_ConditionalPut:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConditionalPut); err != nil {
			return err
		}
	case *ResponseUnion_Delete:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delete); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResponseUnion.Value has unexpected type %T", x)
	}
	return nil
}

func _ResponseUnion_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResponseUnion)
	switch tag {
	case 1: // value.get
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetResponse)
		err := b.DecodeMessage(msg)
		m.Value = &ResponseUnion_Get{msg}
		return true, err
	case 2: // value.put
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PutResponse)
		err := b.DecodeMessage(msg)
		m.Value = &ResponseUnion_Put{msg}
		return true, err
	case 3: // value.conditional_put
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConditionalPutResponse)
		err := b.DecodeMessage(msg)
		m.Value = &ResponseUnion_ConditionalPut{msg}
		return true, err
	case 5: // value.delete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteResponse)
		err := b.DecodeMessage(msg)
		m.Value = &ResponseUnion_Delete{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResponseUnion_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResponseUnion)
	// value
	switch x := m.Value.(type) {
	case *ResponseUnion_Get:
		s := proto.Size(x.Get)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseUnion_Put:
		s := proto.Size(x.Put)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseUnion_ConditionalPut:
		s := proto.Size(x.ConditionalPut)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseUnion_Delete:
		s := proto.Size(x.Delete)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A GetRequest is the argument for the Get() method.
type GetRequest struct {
	RequestHeader        `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{4}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(dst, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

// A GetResponse is the return value from the Get() method.
// If the key doesn't exist, Value will be nil.
type GetResponse struct {
	ResponseHeader       `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value                *roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{5}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(dst, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

// A PutRequest is the argument to the Put() method.
type PutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value         roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// Specify as true to put the value without a corresponding
	// timestamp. This option should be used with care as it precludes
	// the use of this value with transactions.
	Inline bool `protobuf:"varint,3,opt,name=inline,proto3" json:"inline,omitempty"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind                bool     `protobuf:"varint,4,opt,name=blind,proto3" json:"blind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutRequest) Reset()         { *m = PutRequest{} }
func (m *PutRequest) String() string { return proto.CompactTextString(m) }
func (*PutRequest) ProtoMessage()    {}
func (*PutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{6}
}
func (m *PutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutRequest.Merge(dst, src)
}
func (m *PutRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutRequest proto.InternalMessageInfo

// A PutResponse is the return value from the Put() method.
type PutResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutResponse) Reset()         { *m = PutResponse{} }
func (m *PutResponse) String() string { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()    {}
func (*PutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{7}
}
func (m *PutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutResponse.Merge(dst, src)
}
func (m *PutResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutResponse proto.InternalMessageInfo

// A ConditionalPutRequest is the argument to the ConditionalPut() method.
//
// - Returns true and sets value if exp_value equals existing value.
// - If key doesn't exist and exp_value is nil, sets value.
// - If key exists, but value is empty and exp_value is not nil but empty, sets value.
// - Otherwise, returns an error containing the actual value of the key.
type ConditionalPutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The value to put.
	Value roachpb.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// Set exp_value.bytes empty to test for non-existence. Specify as nil
	// to indicate there should be no existing entry. This is different
	// from the expectation that the value exists but is empty.
	ExpValue *roachpb.Value `protobuf:"bytes,3,opt,name=exp_value,json=expValue,proto3" json:"exp_value,omitempty"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind bool `protobuf:"varint,4,opt,name=blind,proto3" json:"blind,omitempty"`
	// Typically if a specific, non-empty expected value is supplied, it *must*
	// exist with that value. Passing this indicates that it is also OK if the key
	// does not exist. This is useful when a given value is expected but it is
	// possible it has not yet been written.
	AllowIfDoesNotExist  bool     `protobuf:"varint,5,opt,name=allow_if_does_not_exist,json=allowIfDoesNotExist,proto3" json:"allow_if_does_not_exist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConditionalPutRequest) Reset()         { *m = ConditionalPutRequest{} }
func (m *ConditionalPutRequest) String() string { return proto.CompactTextString(m) }
func (*ConditionalPutRequest) ProtoMessage()    {}
func (*ConditionalPutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{8}
}
func (m *ConditionalPutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalPutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ConditionalPutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalPutRequest.Merge(dst, src)
}
func (m *ConditionalPutRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalPutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalPutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalPutRequest proto.InternalMessageInfo

// A DeleteRequest is the argument to the Delete() method.
type DeleteRequest struct {
	RequestHeader        `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{9}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(dst, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

// A DeleteResponse is the return value from the Delete() method.
type DeleteResponse struct {
	ResponseHeader       `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{10}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(dst, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

// A ConditionalPutResponse is the return value from the
// ConditionalPut() method.
type ConditionalPutResponse struct {
	ResponseHeader       `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConditionalPutResponse) Reset()         { *m = ConditionalPutResponse{} }
func (m *ConditionalPutResponse) String() string { return proto.CompactTextString(m) }
func (*ConditionalPutResponse) ProtoMessage()    {}
func (*ConditionalPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{11}
}
func (m *ConditionalPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ConditionalPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalPutResponse.Merge(dst, src)
}
func (m *ConditionalPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalPutResponse proto.InternalMessageInfo

// A BatchRequest contains one or more requests to be executed in
// parallel, or if applicable (based on write-only commands and
// range-locality), as a single update.
type BatchRequest struct {
	Header               `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Requests             []RequestUnion `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchRequest) Reset()      { *m = BatchRequest{} }
func (*BatchRequest) ProtoMessage() {}
func (*BatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{12}
}
func (m *BatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchRequest.Merge(dst, src)
}
func (m *BatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchRequest proto.InternalMessageInfo

// A BatchResponse contains one or more responses, one per request
// corresponding to the requests in the matching BatchRequest. The
// error in the response header is set to the first error from the
// slice of responses, if applicable.
type BatchResponse struct {
	BatchResponse_Header `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Responses            []ResponseUnion `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BatchResponse) Reset()      { *m = BatchResponse{} }
func (*BatchResponse) ProtoMessage() {}
func (*BatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{13}
}
func (m *BatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResponse.Merge(dst, src)
}
func (m *BatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResponse proto.InternalMessageInfo

type BatchResponse_Header struct {
	// error communicates a structured error (i.e. one originating from a Node)
	// while the BatchResponse is sent over the network. If the code were
	// written today, the RPC endpoint would return a message containing both a
	// BatchResponse and an Error, and this embedding would go away. However, it
	// returns only a BatchResponse, and so the Error needs to be tucked away
	// somewhere (the structured error cannot be communicated via an RPC-level
	// error).
	//
	// Outside of the RPC boundaries, this field is nil and must neither be
	// checked nor populated (it is reset by the DistSender, which extracts this
	// error and returns it separately). In effect, nearly no usage of
	// BatchResponse needs to care about this field.
	Error                *roachpb.Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchResponse_Header) Reset()         { *m = BatchResponse_Header{} }
func (m *BatchResponse_Header) String() string { return proto.CompactTextString(m) }
func (*BatchResponse_Header) ProtoMessage()    {}
func (*BatchResponse_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{13, 0}
}
func (m *BatchResponse_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResponse_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BatchResponse_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResponse_Header.Merge(dst, src)
}
func (m *BatchResponse_Header) XXX_Size() int {
	return m.Size()
}
func (m *BatchResponse_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResponse_Header.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResponse_Header proto.InternalMessageInfo

// A Header is attached to a BatchRequest, encapsulating routing and auxiliary
// information required for executing it.
type Header struct {
	// Timestamp is used when applying a replicated batch to determine whether
	// the event still needs to be applied. It is part of the mechanism for
	// reorder and replay which can occur due to reproposals.
	//
	// So long as two commands never use the same timestamp value when writing
	// to the same server there is no hazard of non-idempotent multiple
	// application.
	Timestamp *hlc.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Server is the node id which wrote this command.
	Server               github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,opt,name=server,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_24a9b19367ad6b2f, []int{14}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(dst, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RequestHeader)(nil), "cockroach.storage.replication.kvtoy.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "cockroach.storage.replication.kvtoy.ResponseHeader")
	proto.RegisterType((*RequestUnion)(nil), "cockroach.storage.replication.kvtoy.RequestUnion")
	proto.RegisterType((*ResponseUnion)(nil), "cockroach.storage.replication.kvtoy.ResponseUnion")
	proto.RegisterType((*GetRequest)(nil), "cockroach.storage.replication.kvtoy.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "cockroach.storage.replication.kvtoy.GetResponse")
	proto.RegisterType((*PutRequest)(nil), "cockroach.storage.replication.kvtoy.PutRequest")
	proto.RegisterType((*PutResponse)(nil), "cockroach.storage.replication.kvtoy.PutResponse")
	proto.RegisterType((*ConditionalPutRequest)(nil), "cockroach.storage.replication.kvtoy.ConditionalPutRequest")
	proto.RegisterType((*DeleteRequest)(nil), "cockroach.storage.replication.kvtoy.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "cockroach.storage.replication.kvtoy.DeleteResponse")
	proto.RegisterType((*ConditionalPutResponse)(nil), "cockroach.storage.replication.kvtoy.ConditionalPutResponse")
	proto.RegisterType((*BatchRequest)(nil), "cockroach.storage.replication.kvtoy.BatchRequest")
	proto.RegisterType((*BatchResponse)(nil), "cockroach.storage.replication.kvtoy.BatchResponse")
	proto.RegisterType((*BatchResponse_Header)(nil), "cockroach.storage.replication.kvtoy.BatchResponse.Header")
	proto.RegisterType((*Header)(nil), "cockroach.storage.replication.kvtoy.Header")
}
func (this *RequestHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestHeader)
	if !ok {
		that2, ok := that.(RequestHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *GetRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetRequest)
	if !ok {
		that2, ok := that.(GetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestHeader.Equal(&that1.RequestHeader) {
		return false
	}
	return true
}
func (this *PutRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PutRequest)
	if !ok {
		that2, ok := that.(PutRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestHeader.Equal(&that1.RequestHeader) {
		return false
	}
	if !this.Value.Equal(&that1.Value) {
		return false
	}
	if this.Inline != that1.Inline {
		return false
	}
	if this.Blind != that1.Blind {
		return false
	}
	return true
}
func (this *ConditionalPutRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConditionalPutRequest)
	if !ok {
		that2, ok := that.(ConditionalPutRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestHeader.Equal(&that1.RequestHeader) {
		return false
	}
	if !this.Value.Equal(&that1.Value) {
		return false
	}
	if !this.ExpValue.Equal(that1.ExpValue) {
		return false
	}
	if this.Blind != that1.Blind {
		return false
	}
	if this.AllowIfDoesNotExist != that1.AllowIfDoesNotExist {
		return false
	}
	return true
}
func (this *DeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest)
	if !ok {
		that2, ok := that.(DeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestHeader.Equal(&that1.RequestHeader) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InternalClient is the client API for Internal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InternalClient interface {
	Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error)
}

type internalClient struct {
	cc *grpc.ClientConn
}

func NewInternalClient(cc *grpc.ClientConn) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, "/cockroach.storage.replication.kvtoy.Internal/Batch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalServer is the server API for Internal service.
type InternalServer interface {
	Batch(context.Context, *BatchRequest) (*BatchResponse, error)
}

func RegisterInternalServer(s *grpc.Server, srv InternalServer) {
	s.RegisterService(&_Internal_serviceDesc, srv)
}

func _Internal_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.storage.replication.kvtoy.Internal/Batch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Batch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Internal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.storage.replication.kvtoy.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Batch",
			Handler:    _Internal_Batch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage/replication/kvtoy/kvtoypb/api.proto",
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RequestUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestUnion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn1, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *RequestUnion_Get) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Get != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Get.Size()))
		n2, err := m.Get.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *RequestUnion_Put) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Put != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Put.Size()))
		n3, err := m.Put.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *RequestUnion_ConditionalPut) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConditionalPut != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ConditionalPut.Size()))
		n4, err := m.ConditionalPut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *RequestUnion_Delete) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Delete != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Delete.Size()))
		n5, err := m.Delete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *ResponseUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseUnion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn6, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *ResponseUnion_Get) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Get != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Get.Size()))
		n7, err := m.Get.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ResponseUnion_Put) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Put != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Put.Size()))
		n8, err := m.Put.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ResponseUnion_ConditionalPut) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConditionalPut != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ConditionalPut.Size()))
		n9, err := m.ConditionalPut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *ResponseUnion_Delete) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Delete != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Delete.Size()))
		n10, err := m.Delete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.RequestHeader.Size()))
	n11, err := m.RequestHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.ResponseHeader.Size()))
	n12, err := m.ResponseHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Value.Size()))
		n13, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *PutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.RequestHeader.Size()))
	n14, err := m.RequestHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x12
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Value.Size()))
	n15, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.Inline {
		dAtA[i] = 0x18
		i++
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Blind {
		dAtA[i] = 0x20
		i++
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ConditionalPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalPutRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.RequestHeader.Size()))
	n16, err := m.RequestHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x12
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Value.Size()))
	n17, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if m.ExpValue != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExpValue.Size()))
		n18, err := m.ExpValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Blind {
		dAtA[i] = 0x20
		i++
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowIfDoesNotExist {
		dAtA[i] = 0x28
		i++
		if m.AllowIfDoesNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.RequestHeader.Size()))
	n19, err := m.RequestHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	return i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.ResponseHeader.Size()))
	n20, err := m.ResponseHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	return i, nil
}

func (m *ConditionalPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalPutResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.ResponseHeader.Size()))
	n21, err := m.ResponseHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	return i, nil
}

func (m *BatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Header.Size()))
	n22, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.BatchResponse_Header.Size()))
	n23, err := m.BatchResponse_Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BatchResponse_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResponse_Header) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Error.Size()))
		n24, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp.Size()))
		n25, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Server != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Server))
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RequestUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *RequestUnion_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ConditionalPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ResponseUnion_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ConditionalPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Inline {
		n += 2
	}
	if m.Blind {
		n += 2
	}
	return n
}

func (m *PutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ConditionalPutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ExpValue != nil {
		l = m.ExpValue.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Blind {
		n += 2
	}
	if m.AllowIfDoesNotExist {
		n += 2
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ConditionalPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *BatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *BatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BatchResponse_Header.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *BatchResponse_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Server != 0 {
		n += 1 + sovApi(uint64(m.Server))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PutRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Put{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConditionalPutRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ConditionalPut{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Delete{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PutResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Put{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConditionalPutResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ConditionalPut{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Delete{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &roachpb.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpValue == nil {
				m.ExpValue = &roachpb.Value{}
			}
			if err := m.ExpValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowIfDoesNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowIfDoesNotExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, RequestUnion{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponse_Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchResponse_Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, ResponseUnion{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResponse_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &roachpb.Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &hlc.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("storage/replication/kvtoy/kvtoypb/api.proto", fileDescriptor_api_24a9b19367ad6b2f)
}

var fileDescriptor_api_24a9b19367ad6b2f = []byte{
	// 880 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x96, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0x63, 0xc7, 0xc9, 0xba, 0x2f, 0x4d, 0x89, 0x86, 0x52, 0xac, 0x48, 0x24, 0xc5, 0x5c,
	0x2a, 0xad, 0x64, 0x77, 0x93, 0x22, 0x44, 0x57, 0xe2, 0x90, 0xcd, 0xc2, 0xb6, 0xb0, 0x0b, 0x32,
	0x6d, 0x0f, 0x70, 0x88, 0x1c, 0x7b, 0x9a, 0x58, 0x71, 0x3c, 0xc6, 0x9e, 0x94, 0x56, 0xe2, 0x13,
	0x70, 0xe2, 0x80, 0x10, 0xc7, 0x7e, 0x00, 0x3e, 0x00, 0x1f, 0xa1, 0x07, 0x0e, 0x3d, 0x21, 0x24,
	0xa4, 0x08, 0xc2, 0x85, 0xcf, 0xd0, 0x13, 0xf2, 0x78, 0x12, 0x3b, 0x69, 0x2a, 0x1c, 0xa4, 0x48,
	0x5c, 0xa2, 0xf1, 0xcc, 0xbc, 0xff, 0x9b, 0xf7, 0x7b, 0xef, 0x4d, 0x06, 0x1e, 0x87, 0x94, 0x04,
	0x66, 0x0f, 0xeb, 0x01, 0xf6, 0x5d, 0xc7, 0x32, 0xa9, 0x43, 0x3c, 0x7d, 0x70, 0x41, 0xc9, 0x55,
	0xfc, 0xeb, 0x77, 0x75, 0xd3, 0x77, 0x34, 0x3f, 0x20, 0x94, 0xa0, 0x77, 0x2c, 0x62, 0x0d, 0x02,
	0x62, 0x5a, 0x7d, 0x8d, 0x9b, 0x69, 0x29, 0x33, 0x8d, 0x19, 0x54, 0xb7, 0xd9, 0x06, 0xbf, 0xab,
	0xe3, 0x20, 0x20, 0x41, 0x18, 0x9b, 0x56, 0x77, 0xa6, 0xb3, 0x43, 0x4c, 0x4d, 0xdb, 0xa4, 0x26,
	0x9f, 0x47, 0xd3, 0xf9, 0xd4, 0xdc, 0x76, 0x8f, 0xf4, 0x08, 0x1b, 0xea, 0xd1, 0x88, 0xcf, 0x2a,
	0x23, 0xea, 0xb8, 0x7a, 0xdf, 0xb5, 0x74, 0xea, 0x0c, 0x71, 0x48, 0xcd, 0xa1, 0x1f, 0xaf, 0xa8,
	0x0e, 0x94, 0x0d, 0xfc, 0xd5, 0x08, 0x87, 0xf4, 0x05, 0x36, 0x6d, 0x1c, 0xa0, 0x0f, 0x21, 0x3f,
	0xc0, 0x57, 0x4a, 0x7e, 0x57, 0xd8, 0xdb, 0x6c, 0x1d, 0xdc, 0x8d, 0xeb, 0xfb, 0x3d, 0x87, 0xf6,
	0x47, 0x5d, 0xcd, 0x22, 0x43, 0x7d, 0x16, 0x83, 0xdd, 0x4d, 0xc6, 0xba, 0x3f, 0xe8, 0xe9, 0xfc,
	0x28, 0xda, 0xc7, 0xf8, 0xca, 0x88, 0x04, 0x0e, 0xa5, 0xbf, 0xaf, 0xeb, 0xc2, 0xb1, 0x24, 0x0b,
	0x15, 0xf1, 0x58, 0x92, 0xc5, 0x4a, 0x5e, 0xad, 0xc0, 0x96, 0x81, 0x43, 0x9f, 0x78, 0x21, 0x8e,
	0x7d, 0xa9, 0xbf, 0x8a, 0xb0, 0xc9, 0xbd, 0x9f, 0x7a, 0x0e, 0xf1, 0xd0, 0x33, 0xc8, 0xf7, 0x30,
	0x55, 0x84, 0x5d, 0x61, 0xaf, 0xd4, 0xd0, 0xb5, 0x0c, 0xc8, 0xb4, 0x8f, 0x30, 0x9d, 0x06, 0x90,
	0x33, 0x22, 0xeb, 0x48, 0xc4, 0x1f, 0x51, 0x45, 0x5c, 0x41, 0xe4, 0xb3, 0x51, 0x5a, 0xc4, 0x1f,
	0x51, 0x84, 0xe1, 0x35, 0x8b, 0x78, 0xb6, 0x13, 0x6d, 0x32, 0xdd, 0x4e, 0x24, 0x98, 0x67, 0x82,
	0x87, 0x99, 0x04, 0x9f, 0x25, 0xb6, 0x73, 0xda, 0x5b, 0xd6, 0xdc, 0x02, 0xfa, 0x04, 0x8a, 0x36,
	0x76, 0x31, 0xc5, 0x4a, 0x81, 0xa9, 0x37, 0x32, 0xa9, 0xb7, 0x99, 0x49, 0xa2, 0xca, 0x35, 0x5a,
	0x8f, 0xa0, 0x70, 0x61, 0xba, 0x23, 0xac, 0xfe, 0x2e, 0x46, 0x69, 0x8d, 0x59, 0xc7, 0x64, 0xdb,
	0x69, 0xb2, 0xfb, 0xd9, 0xc9, 0xf2, 0x7c, 0x71, 0xb4, 0xed, 0x34, 0xda, 0xfd, 0xec, 0x68, 0x13,
	0x95, 0x88, 0xed, 0xf9, 0x43, 0x6c, 0x9f, 0xfe, 0x27, 0xb6, 0x33, 0xf1, 0x45, 0xb8, 0x2f, 0x17,
	0xe0, 0x36, 0x57, 0x82, 0x3b, 0x93, 0xbd, 0x47, 0xb7, 0x0f, 0x90, 0x54, 0x1d, 0x3a, 0x81, 0x62,
	0x9f, 0x95, 0x33, 0x87, 0x9b, 0x2d, 0x85, 0x73, 0x4d, 0xd7, 0x92, 0x6f, 0xc6, 0xf5, 0xdc, 0xed,
	0xb8, 0x2e, 0x18, 0x5c, 0x2b, 0x6e, 0x1f, 0xf5, 0x7b, 0x01, 0x4a, 0xa9, 0x34, 0xa0, 0xd3, 0x05,
	0x5f, 0xcd, 0x8c, 0xbe, 0xd2, 0x5d, 0x77, 0xdf, 0x19, 0xd2, 0x78, 0x64, 0x3c, 0xb1, 0x4a, 0x4a,
	0x75, 0xda, 0xd7, 0x67, 0xd1, 0xba, 0xc1, 0x01, 0xfc, 0x22, 0x00, 0x24, 0x65, 0xbd, 0x1e, 0x02,
	0xe8, 0x20, 0xe3, 0xa1, 0x5a, 0x52, 0x64, 0xca, 0x8f, 0x86, 0x76, 0xa0, 0xe8, 0x78, 0xae, 0xe3,
	0x61, 0x56, 0x52, 0xb2, 0xc1, 0xbf, 0xd0, 0x36, 0x14, 0xba, 0xae, 0xe3, 0xd9, 0x8a, 0xc4, 0xa6,
	0xe3, 0x0f, 0x4e, 0xb9, 0x0c, 0xa5, 0x54, 0x21, 0xa9, 0x3f, 0x89, 0xf0, 0xc6, 0xd2, 0xfe, 0xfd,
	0x5f, 0x05, 0xfa, 0x2e, 0x6c, 0xe0, 0x4b, 0xbf, 0x13, 0x5b, 0xe6, 0xff, 0x25, 0x6f, 0x32, 0xbe,
	0xf4, 0xd9, 0x68, 0x39, 0x07, 0x74, 0x00, 0x6f, 0x9a, 0xae, 0x4b, 0xbe, 0xee, 0x38, 0xe7, 0x1d,
	0x9b, 0xe0, 0xb0, 0xe3, 0x11, 0xda, 0xc1, 0x97, 0x4e, 0x48, 0x59, 0xeb, 0xc8, 0xc6, 0xeb, 0x6c,
	0xf9, 0xe8, 0xbc, 0x4d, 0x70, 0xf8, 0x8a, 0xd0, 0xe7, 0xd1, 0x12, 0xa7, 0x37, 0x80, 0xf2, 0xdc,
	0x7d, 0xb4, 0xd6, 0x86, 0xe8, 0xc1, 0xd6, 0x7c, 0x7f, 0xae, 0xa9, 0x25, 0x54, 0x02, 0x3b, 0xcb,
	0xef, 0x99, 0x75, 0x39, 0xfc, 0x59, 0x80, 0xcd, 0x96, 0x49, 0xad, 0xfe, 0x14, 0xe3, 0xcb, 0x05,
	0x3f, 0x8f, 0x33, 0xf9, 0x79, 0xb0, 0xca, 0x3e, 0x07, 0x39, 0x88, 0x95, 0x43, 0x45, 0xdc, 0xcd,
	0xef, 0x95, 0x1a, 0x4f, 0x56, 0xc9, 0x0b, 0xfb, 0x17, 0xe1, 0x15, 0x38, 0x13, 0x3a, 0x94, 0x7e,
	0xbc, 0xae, 0xe7, 0xd4, 0x6f, 0x45, 0x28, 0xf3, 0xa3, 0x73, 0x46, 0x5f, 0x2e, 0x9c, 0xfd, 0xfd,
	0x4c, 0xae, 0xe6, 0x34, 0x1e, 0x8e, 0xe4, 0x0c, 0x36, 0x02, 0xbe, 0x69, 0x1a, 0x4a, 0x63, 0xa5,
	0x1c, 0xa4, 0x63, 0x49, 0xa4, 0xaa, 0x1f, 0x40, 0xf1, 0xc5, 0xec, 0x3e, 0x64, 0x0f, 0x30, 0x7e,
	0xfa, 0x65, 0x7d, 0xf5, 0x3c, 0x5a, 0x37, 0xe2, 0x6d, 0xc7, 0x92, 0x2c, 0x55, 0x0a, 0x1c, 0xc6,
	0x0f, 0xc2, 0x4c, 0xe6, 0x29, 0x6c, 0xcc, 0x9e, 0x5b, 0x5c, 0xea, 0xad, 0x94, 0x54, 0xf4, 0x26,
	0xd3, 0xfa, 0xae, 0xa5, 0x9d, 0x4c, 0x37, 0x19, 0xc9, 0x7e, 0xf4, 0x29, 0x14, 0x43, 0x1c, 0x5c,
	0xe0, 0x80, 0x5d, 0x0b, 0x85, 0xd6, 0x7b, 0x77, 0xe3, 0x7a, 0x73, 0xa5, 0xa7, 0xd8, 0x2b, 0x62,
	0xe3, 0xa3, 0xb6, 0xc1, 0x65, 0x1a, 0xdf, 0x80, 0x7c, 0xe4, 0x51, 0x1c, 0x78, 0xa6, 0x8b, 0x7c,
	0x28, 0x30, 0xd8, 0xe8, 0xc9, 0x2a, 0x89, 0x61, 0x49, 0xaf, 0x36, 0x56, 0xcf, 0xa5, 0x9a, 0x6b,
	0xbd, 0x7d, 0xf3, 0x67, 0x2d, 0x77, 0x33, 0xa9, 0x09, 0xb7, 0x93, 0x9a, 0xf0, 0xdb, 0xa4, 0x26,
	0xfc, 0x31, 0xa9, 0x09, 0xdf, 0xfd, 0x55, 0xcb, 0x7d, 0xf1, 0x88, 0xbf, 0x95, 0xbb, 0x45, 0xf6,
	0x22, 0x6d, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x04, 0x32, 0xd6, 0xb3, 0x57, 0x0b, 0x00, 0x00,
}
